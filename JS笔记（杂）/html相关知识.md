

- 从输入url到得到html的过程

  1. 输入资源地址，发起请求

     - 构建请求行

  2. 浏览器缓存机制，优先查找本地有无缓存可用

     - 先检查强缓存，如果命中直接使用，否则进入DNS解析。
     - 由于我们输入的是域名，而数据包是通过`IP地址`传给对方的。因此我们需要得到域名对应的`IP地址`。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做**DNS**（域名系统）。得到具体 IP 的过程就是`DNS`解析。

     1. 搜索自身DNS缓存
     2. 搜索操作系统自身的DNS缓存
     3. 读取本地的HOST文件
     4. 发起一个DNS的系统调用

  3. 浏览器向DNS服务器发起域名解析 请求

     1. 宽带运营服务查看本身缓存
     2. 向运营商服务器发起一个迭代DNS解析的请求
     3. 运营服务商把结果返回操作系统内核同时缓存起来
     4. 操作系统内核吧结果返回浏览器
     5. 浏览器拿到域名对应的IP地址

  4. 建立与服务器的TCP/IP连接，三次握手过程

     - 握手挥手详解：https://zhuanlan.zhihu.com/p/86426969

  5. 想服务器发送http/https请求，创建端口

     1. 要携带请求行，请求头和请求体
     2. 请求行由**请求方法**、**请求URI**和**HTTP版本协议**组成。
     3. 请求体只有在`POST`方法下存在，常见的场景是**表单提交**。

  6. 服务器在端口监听客户端请求

     1. 接受请求，根据路径参数，经过后端处理后
     2. 返回状态和内容
     3. 响应完成后，要判断`Connection`字段, 如果请求头或响应头中包含**Connection: Keep-Alive**，表示建立了持久连接，这样`TCP`连接会一直保持，之后请求统一站点的资源会复用这个连接。

  7. 服务器得到返回内容

     1. 拿到HTML页面代码，开始解析页面
     2. 碰到的js、css、图片等静态资源，发起请求
     3. 从发起请求到返回结果，同样经过上面的步骤
     4. 根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给用户

- 浏览器渲染页面的过程

  1. 根据html结构生成DOM Tree
  2. 根据css生成CSSOM
  3. 将DOM和CSSOM整合形成RenderTree
  4. 根据RenderTree开始渲染和展示
  5. 遇到script标签时，会执行并阻塞渲染，因为js代码会改变DOM树



- 浏览器的解析算法

  - 构建DOM树

    - html文法的本质，非上下文无关文法

    - 解析算法

      - 标记化，输入为html文本，输出为htm标记

        ```
        <html>
          <body>
            Hello sanyuan
          </body>
        </html>
        
        遇到<, 状态为标记打开。
        接收[a-z]的字符，会进入标记名称状态。
        这个状态一直保持，直到遇到>，表示标记名称记录完成，这时候变为数据状态。
        接下来遇到body标签做同样的处理。
        这个时候html和body的标记都记录好了。
        现在来到<body>中的>，进入数据状态，之后保持这样状态接收后面的字符hello sanyuan。
        接着接收 </body> 中的<，回到标记打开, 接收下一个/后，这时候会创建一个end tag的token。
        随后进入标记名称状态, 遇到>回到数据状态。
        接着以同样的样式处理 </body>。
        ```

      - 建树，DOM树是一个以document为根节点的多叉树。所以解析器首先会创建一个document对象。标记生成器会把每个标记的信息发送给建树器。建树器接受到相应的标记时，会创建对应的DOM对象。创建对象后会做两件事情：

        1. 将DOM对象加入DOM树中
        2. 将对应标记压入存放开放元素的栈中
           - 首先，状态为**初始化状态**。
           - 接收到标记生成器传来的`html`标签，这时候状态变为**before html状态**。同时创建一个`HTMLHtmlElement`的 DOM 元素, 将其加到`document`根对象上，并进行压栈操作。
           - 接着状态自动变为**before head**, 此时从标记生成器那边传来`body`，表示并没有`head`, 这时候**建树器**会自动创建一个**HTMLHeadElement**并将其加入到`DOM树`中。
           - 现在进入到**in head**状态, 然后直接跳到**after head**。
           - 现在**标记生成器**传来了`body`标记，创建**HTMLBodyElement**, 插入到`DOM`树中，同时压入开放标记栈。
           - 接着状态变为**in body**，然后来接收后面一系列的字符: **Hello sanyuan**。接收到第一个字符的时候，会创建一个**Text**节点并把字符插入其中，然后把**Text**节点插入到 DOM 树中`body元素`的下面。随着不断接收后面的字符，这些字符会附在**Text**节点上。
           - 现在，**标记生成器**传过来一个`body`的结束标记，进入到**after body**状态。
           - **标记生成器**最后传过来一个`html`的结束标记, 进入到**after after body**的状态，表示解析过程到此结束。

  - 样式计算

    - 一般有：link标签引用，style标签中的样式，元素的内嵌style属性
    - 格式化样式表：浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。
    - 标准化样式属性：因此需要在计算样式之前将它们标准化，如`em`->`px`,`red`->`#ff0000`,`bold`->`700`等等。
    - 计算每个节点的具体样式，主要是两个规则：
      1. 继承，每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫`UserAgent样式`。
      2. 层叠

  - 生成布局树

    1. 遍历生成的DOM树节点，并把他们添加到布局树种
    2. 计算布局树节点的坐标位置
       - 布局树值包含可见元素。对于head标签和display：none的元素，不会被放入其中。
       - 先生成RenderTree是16年前的事，chrome团队做了大量重构，已经没有这个过程了。

  - 布局细节：https://www.rrfed.com/2017/02/26/chrome-layout/

- 浏览器渲染过程篇

  - 建图层树
    - 布局树之后，会对特定的节点进行分层，构建一棵图层树
    - 显式合成
      - 拥有层叠上下文的节点
        1. HTML根元素本身就具有层叠上下文。
        2. 普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。
        3. 元素的 **opacity** 值不是 1
        4. 元素的 **transform** 值不是 none
        5. 元素的 **filter** 值不是 none
        6. 元素的 **isolation** 值是isolate
        7. **will-change**指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)
      - 需要剪裁的地方，比如文字超出部分需要被剪裁。
    - 隐式合成
      - `层叠等级低`的节点被提升为单独的图层之后，那么`所有层叠等级比它高`的节点**都会**成为一个单独的图层。
  - 生成绘制列表，将图层的绘制拆分为一个个绘制指令，相当于给后面的绘制操作做了一波计划。
  - 生成图块和生成位图。绘制列表准备好了之后，渲染进程的主线程会给`合成线程`发送`commit`消息，把绘制列表提交给合成线程。首次合成优化，图块栅格化。
  - 显示器显示内容。
    - 栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。
    - 浏览器进程中的`viz组件`接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。
    - 显示器显示图像：无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。



- 回流（重排）
  - 触发条件，对dom结构的修改导致dom集合尺寸变化的时候，会发生回流的过程。
  - 回流过程：如果dom结构发生改变，则重新渲染dom树，然后将后面的流程全部走一遍。
- 重绘
  - 触发条件，dom的修改导致样式的变化，但是没影响几何属性的时候，会导致重回
  - 重绘过程：跳过生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。
  - 重绘不一定导致回流，回流一定发生重绘。
- 合成
  - 比如利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU加速**。
- GPU加速的原因
  - 在合成的情况下，会直接跳过布局和绘制流程，直接进入`非主线程`处理的部分，即直接交给`合成线程`处理。交给它处理有两大好处:
    1. 能够充分发挥`GPU`的优势。合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而GPU 是擅长处理位图数据的。
    2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。
- 实践意义
  - 对开发的指导意义：
    1. 避免频繁使用 style，而是采用修改`class`的方式。
    2. 使用`createDocumentFragment`进行批量的 DOM 操作。
    3. 对于 resize、scroll 等进行防抖/节流处理。
    4. 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于`tranform`, 任何可以实现合成效果的 CSS 属性都能用`will-change`来声明。这里有一个实际的例子，一行`will-change: tranform`拯救一个项目，[点击直达](https://juejin.im/post/6844903966573068301)。

- JS和CSS文件位置
  1. JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。
  2. CSS 不会阻塞后续 DOM 结构的解析，不会阻塞其它资源(如图片)的加载，但是会阻塞 JS 文件的加载。
  3. 现代浏览器很聪明，会进行 prefetch 优化，浏览器在获得 html 文档之后会对页面上引用的资源进行提前下载。
  4. 结论
     1. 将样式或 CSS 文件定义在 head 中，并且在处理此类请求的时候应该尽快能够响应(CDN 什么的)。
     2. 将 JS 脚本文件放在 body 底部，让 DOM 结构能优先渲染出来，避免 DOM 被阻塞。
     3. 当编写比较耗时的 JS 代码时候尽可能使用异步的方式进行加载，比如 setTimeout, ajax 等等，同样也是为了避免页面渲染耗时过长，影响用户体验。



- 浏览器缓存

  - 浏览器中的缓存作用分为两种情况，一种是需要发送`HTTP`请求，一种是不需要发送。
- 强缓存：这个阶段`不需要`发送HTTP请求。在早期，也就是`HTTP/1.0`时期，使用的是**Expires**，而`HTTP/1.1`使用的是**Cache-Control**。
  - `Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。有个问题是**服务器的时间和浏览器的时间可能并不一致**，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。
  - Cache-Control。它可以组合非常多的指令，完成更多场景的缓存判断
  - 当资源时间超时了，强缓存失效了，进入第二级屏障，协商缓存。浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**。这样的缓存tag分为两种: **Last-Modified**（该资源的最后修改时间） 和 **ETag**（服务器根据当前文件的内容，给文件生成的唯一表示，只要内容有改动，值就会变）。这两者各有优劣，并不存在谁对谁有`绝对的优势`，跟上面强缓存的两个 tag 不一样。etag更进准，last-modified性能上更好。
  - 缓存位置，浏览器的缓存位置一共有四种，优先级从高到低分别是
    - Service Worker，离线缓存
    - Memory Cache，内存缓存
    - Disk Cache，磁盘中的缓存，比较大的js，css文件，内存使用率比较高的时候，文件优先进入磁盘
    - Push Cache，推送缓存，浏览器缓存的最后一道防线。
  - 总结：
    1. 先通过 `Cache-Control` 验证强缓存是否可用
    2. 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新
       - 若资源更新，返回资源和200状态码
       - 否则，返回304，告诉浏览器直接从缓存获取资源
- 浏览器的本地存储
  - cookie
    - 最开始是为了弥补http在状态管理上的不足，因为http是一个无状态协议。
    - 本质上是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。
    - 缺点：
      1. 体积上限4kb，只能存储少量信息
      2. 性能缺陷，cookie紧跟域名，不管域名下某个地址需不需要cookie，都会携带上完整cookie，造成性能浪费
      3. 安全缺陷。很容易被用户截获并篡改
  - webstorage
    - localstorage
      1. 针对域名，同一个域名存相同的loacalstorage
      2. 容量上线5m，只存在客户端，不参与服务端的通信
      3. 接口封装，通过setitem和getitem操作起来非常方便。
      4. 利用较大容量和持久性，存储一些内容稳定的资源
    - sessionstorage
      1. 1，2，3和上述一致
      2. 会话级别，并不持久化存储，页面关闭，就不存在了。
      3. 对表单信息进行维护，刷新页面不丢失信息。
      4. 存储本次浏览的记录。
  - indexedDB
    - 运行再浏览器中的非关系型数据库



- XSS攻击

  - 定义：全称是 `Cross Site Scripting`(即`跨站脚本`)，为了和 CSS 区分，故叫它`XSS`。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

  - 一般做下面这些事情：

    1. 窃取cookie
    2. 监听用户行为，输入账号密码后直接发送到黑客服务器
    3. 修改DOM伪造登录表单
    4. 在页面中生成浮窗广告。

  - 实现有三种方式，存储型，反射型和文档型

    - 存储型

      - 顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。
      - 常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中`直接执行`, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。

    - 反射型

      - 指恶意脚本作为网络请求的一部分

        ```
        http://sanyuan.com?q=<script>alert("你完蛋了")</script>
        ```

      - 之所以叫它`反射型`, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和`存储型`不一样的是，服务器并不会存储这些恶意脚本。

    - 文档型

      - 文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后**修改里面的 html 文档**！这样的劫持方式包括`WIFI路由器劫持`或者`本地恶意软件`等。

    - 防范措施

      - 不要相信用户的输入，对用户的输入进行转码或者过滤
      - CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:
        1. 限制其他域下的资源加载。
        2. 禁止向其它域提交数据。
        3. 提供上报机制，能帮助我们及时发现 XSS 攻击
      - 利用httponly，很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

  - CSRF攻击

    - 跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户**目前的登录状态**发起跨站请求。可能发送GET请求，自动带上cookie信息。发POST请求，黑客自己填了一个表单，写了个自动提交的脚本。
    - 防范措施
      - 利用coockie的samesite属性，对请求中的cookie的携带做一些限制
      - 验证来源站点，用到请求头中的两个字段: **Origin**和**Referer**。其中，**Origin**只包含域名信息，而**Referer**包含了`具体`的 URL 路径。这两个都可以伪造，安全性略差
      - CSRF Token，服务器生成一个字符串作为token，如果浏览器要求发送请求，必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。

  - HTTPS

    - http的特性是明文传输，所以容易被篡改
    - https是在http和tcp之间建立一个中间层，通信的时候直接进过一个中间层进行加密，将加密后的数据传给tcp响应，tcp必须把数据包解密，才能传给上面的http，中间层也叫安全层，核心是对数据加解密。
    - 对称加密，加密和解密用的相同的秘钥
    - 非对称加密，如果有ab两把秘钥，用a加密过的
    - 加密过程
      1. 首先，浏览器会给服务器发送一个随机数`client_random`和一个加密的方法列表。
      2. 服务器接收后给浏览器返回另一个随机数`server_random`和加密方法。
      3. 现在，两者拥有三样相同的凭证: `client_random`、`server_random`和加密方法。
      4. 接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的`暗号`。
    - 非对称加密过程
      1. 在这种加密方式中，服务器手里有两把钥匙，一把是`公钥`，也就是说每个人都能拿到，是公开的，另一把是`私钥`，这把私钥只有服务器自己知道。
      2. 浏览器把`client_random`和加密方法列表传过来，服务器接收到，把`server_random`、`加密方法`和`公钥`传给浏览器。
      3. 现在两者拥有相同的`client_random`、`server_random`和加密方法。然后浏览器用公钥将`client_random`和`server_random`加密，生成与服务器通信的`暗号`。
      4. 这时候由于是**非对称加密**，公钥加密过的数据只能用`私钥`解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
      5. 但是服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。
    - 对称加密和非对称加密的结合
      1. 浏览器向服务器发送`client_random`和加密方法列表。
      2. 服务器接收到，返回`server_random`、加密方法以及公钥。
      3. 浏览器接收，接着生成另一个随机数`pre_random`, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)
      4. 服务器用私钥解密这个被加密后的`pre_random`。
      5. 现在浏览器和服务器有三样相同的凭证:`client_random`、`server_random`和`pre_random`。然后两者用相同的加密方法混合这三个随机数，生成最终的`密钥`。
      6. 然后浏览器和服务器尽管用一样的密钥进行通信，即使用`对称加密`。
      7. 还是存在一些问题，黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。
    - 添加数字证书，证明自己的身份。
      - 作用
        1. 服务器向浏览器证明自己的身份。
        2. 把公钥传给浏览器。
      - 当服务器传送`server_random`、加密方法的时候，顺便会带上`数字证书`(包含了`公钥`), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。
      - 认知过程
        1. 首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到`信息A`，然后用公钥解密明文内容得到`信息B`，两份信息做比对，一致则表示认证合法。
        2. 当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。

- 事件的防抖和节流

  - 节流，如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器`完成`，才能启动**下一个定时器任务**。
  - 防抖，每次事件触发则删除原来的定时器，建立新的定时器。

- 图片懒加载

  - clientHeight、scrollTop、offsetTop
  - getBoundingClintRect
  - intersectionOBserver，这是浏览器内置的一个`API`，实现了`监听window的scroll事件`、`判断是否在视口中`以及`节流`三大功能。
